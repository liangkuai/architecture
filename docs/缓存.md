# 缓存

***缓存的本质思想就是空间换时间。***


### 缓存分类

#### 1. 本地缓存
#### 2. 分布式缓存
当缓存的数据量增大以后，单机不足以承载时，就要考虑对缓存服务做水平扩展，引入缓存集群。

将数据分片后分散存储在不同机器中，如何决定每个数据分片存放在哪台机器呢？一般是采用「**一致性 Hash 算法**」，它能够保证在缓存集群动态调整，不断增加或者减少机器后，客户端访问时依然能够根据 key 访问到数据。


### 缓存使用场景
#### 1. 适用场景
- 读多写少
- 计算耗时大，且实时性不高

#### 2. 不适用场景
- 写多读少，频繁更新
- 对数据一致性要求严格
- 数据访问完全随机


### 缓存更新策略

#### 1. Cache-Aside
- 读，先读缓存，没命中就读库并更新缓存
- 写，先入库，然后设置缓存失效

#### 2. Cache-As-SoR
> SoR，System of Record，记录系统，表示数据源，一般就是数据库。

从字面上来看，就是把 Cache 当作 SoR，也就是数据源，所以一切读写操作都是针对 Cache 的，由 Cache 内部自己维护和数据源的一致性。

Cache-As-SoR 又分为以下三种方式:

- Read Through ：和 Cache-Aside 非常相似，都是在查询时发生 cache miss 去更新缓存，但是区别在于 Cache-Aside 需要调用方手动更新缓存，而 Cache-As-SoR 则是由缓存内部实现自己负责，对应用层透明。

- Write Through ：直写式，就是在将数据写入缓存的同时，缓存也去更新后面的数据源，并且必须等到数据源被更新成功后才可返回。这样保证了缓存和数据库里的数据一致性。

- Write Back ：回写式，数据写入缓存即可返回，缓存内部会异步的去更新数据源，这样好处是写操作特别快，因为只需要更新缓存。并且缓存内部可以合并对相同数据项的多次更新，但是带来的问题就是数据不一致，可能发生写丢失。