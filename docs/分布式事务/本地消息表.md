# 本地消息表

本地消息表这个方案最初是 ebay 架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章。

方案的核心是把需要分布式处理的任务通过消息日志的方式异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或者人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。

### 流程
1. A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；
2. 接着 A 系统将这个消息发送到 MQ 中去；
3. B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；
4. B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；
5. 如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；

![本地消息表](/assets/images/分布式事务/本地消息表.jpg)

这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。

这个方案最大的问题就在于严重依赖于数据库的消息表来管理事务啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。






另外有一种类似 TCC 的事务解决方案，借助本地消息表来实现。假设要在一个分布式事务中实现调用 repo-service 扣减库存、调用 order-service 生成订单两个过程。在这种方案中，协调者 shopping-service 维护一张如下的本地消息表：

| 分布式事务 ID | 事务内容 | 事务状态 |
| :--: | :-- | :-- |
| global_trx_id_1 | 操作 1：调用 repo-service 扣减库存<br>操作 2：调用 order-service 生成订单 | 状态 1：初始<br>状态 2：操作 1 成功<br>状态 3：操作 1、2 成功 |

初始状态为 1，每成功调用一个服务则更新一次状态，最后所有的服务调用成功，状态更新到 3。

有了这张表，就可以启动一个后台任务，扫描这张表中事务的状态，如果一个分布式事务一直（设置一个事务周期阈值）未到状态 3，说明这条事务没有成功执行，于是可以重新调用 repo-service 扣减库存、调用 order-service 生成订单。直至所有的调用成功，事务状态到 3。

如果多次重试仍未使得状态到 3，可以将事务状态置为 error，通过人工介入进行干预。

由于存在服务的调用重试，因此每个服务的接口要根据全局的分布式事务 ID 做幂等。而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。


可以看到本地消息表其实实现的是最终一致性，容忍了数据暂时不一致的情况。




### 参考
- [1.4w字，25 张图让你彻底掌握分布式事务原理 - allentofight - GitBook](https://codesea.gitbook.io/allentofight/xi-tong-she-ji/1.4w-zi-25-zhang-tu-rang-ni-che-di-zhang-wo-fen-bu-shi-shi-wu-yuan-li)
- [分布式事务 - 三太子敖丙 - 微信公众号](https://mp.weixin.qq.com/s/XknegP66mnYboiBx556Kzw)