# TCC（补偿事务）

如果说 2PC 和 3PC 都是数据库层面的分布式事务方案，也就是只涉及数据库操作；那么 TCC 就是业务层面的分布式事务，还包括推送等等。

TCC 指的是 Try-Confirm-Cancel，
- Try，预留，资源的预留和锁定
- Confirmm，确认，执行操作
- Cancel，撤销，把预留阶段的动作撤销

TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。

TCC 由支付宝团队提出，被广泛应用于金融系统中。我们用银行账户余额购买基金时，会注意到银行账户中用于购买基金的那部分余额首先会被冻结，由此我们可以猜想，这个过程大概就是 TCC 的第一阶段。

### 步骤
TCC 本质是一个应用层面上的 2PC，同样可以看成两个阶段：

#### 1. Try 阶段
主要是对业务系统做检测及资源预留。协调者调用所有的每个服务提供的 Try 接口，将整个全局事务涉及到的资源锁定住，若锁定成功 Try 接口向协调者返回 yes。

#### 2. Confirm 阶段
主要是对业务系统做确认提交。如果所有的服务的 Try 接口在阶段一都返回 yes，那就进入提交阶段，协调者调用所有服务的 Confirm 接口，各个服务进行事务提交。默认 Confirm 阶段是不会出错的，即：只要 Try 成功，Confirm 一定成功。

#### 3. Cancel 阶段
主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。如果有任何一个服务的 Try 接口在阶段一返回 no 或者超时，协调者就调用所有服务的 Cancel 接口。


### 问题
1. 这里有个关键问题，既然 TCC 是一种业务层面上的 2PC，它是如何解决 2PC 无法应对宕机问题的缺陷的呢？答案是不断重试。由于 Try 操作锁住了全局事务涉及的所有资源，保证了业务操作的所有前置条件得到满足，因此无论是 Confirm 阶段失败还是 Cancel 阶段失败都能通过不断重试直至 Confirm 或 Cancel 成功（所谓成功就是所有的服务都对 Confirm 或者 Cancel 返回了 ACK）。

2. 这里还有个关键问题，在不断重试 Confirm 和 Cancel 的过程中（考虑到二将军问题的存在）有可能重复进行了 Confirm 或 Cancel，因此还要再保证 Confirm 和 Cancel 操作具有幂等性，也就是整个全局事务中，每个参与者只进行一次 Confirm 或者 Cancel。实现 Confirm 和 Cancel 操作的幂等性，有很多解决方案，例如每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标记 XID 区分）是否进行过 Confirm 或 Cancel 操作，若已经进行过，则不再重复执行。


### 优点
跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。


### 缺点
缺点还是比较明显的，在 2、3 步中都有可能失败。

TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。



### 参考
- [1.4w字，25 张图让你彻底掌握分布式事务原理 - allentofight - GitBook](https://codesea.gitbook.io/allentofight/xi-tong-she-ji/1.4w-zi-25-zhang-tu-rang-ni-che-di-zhang-wo-fen-bu-shi-shi-wu-yuan-li)
- [分布式事务 - 三太子敖丙 - 微信公众号](https://mp.weixin.qq.com/s/XknegP66mnYboiBx556Kzw)