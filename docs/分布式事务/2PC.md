# 2PC

Two-Phase Commit，二阶段提交。

为了使基于分布式系统下的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。通常，2PC 协议也被认为是一种一致性协议，用来保证分布式系统数据的一致性。

目前，绝大部分的关系型数据库都是采用 2PC 协议来完成分布式事务处理的，利用该协议能够非常方便的完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据一致性，因此 2PC 协议被广泛地应用在许多分布式系统中。


### 流程
2PC 引入一个事务协调者的角色来协调管理各个参与者的提交和回滚。二阶段指的是准备和提交两个阶段。

#### 第一阶段：准备
- 事务协调者向每个涉及到事务的数据库（事务参与者）发起询问请求：“我要执行全局事务了，这个事务涉及到的资源分布在你们这些数据源中，分别是...，你们准备好各自的资源（即各自执行本地事务到待提交阶段）”；
- 事务协调器同步等待所有参与者的响应，就进入第二阶段；
- 各个参与者协调者回复 yes（表示已准备好，允许提交全局事务）或 no（表示本参与者无法拿到全局事务所需的本地资源，因为它被其他本地事务锁住了）或超时。

#### 第二阶段：提交
- 如果各个参与者回复的都是 yes，那么协调者向所有参与者发起事务提交操作，然后所有参与者收到后各自执行本地事务提交操作并向协调者发送 ACK；
- 如果任何一个参与者回复 no 或者超时，那么协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 ACK。

> 如果第二阶段，有数据库失败怎么办？
> - 如果第二阶段执行的是提交事务操作，那就不断重试，直到提交成功，最好实在不行只能人工介入处理。
> - 如果第二阶段执行的是回滚事务操作，那也是不断重试，直到所有参与者回滚。


### 实现
要实现 2PC，所有的参与者都要实现三个接口：
- Prepare()：TM 调用该接口询问各个本地事务是否就绪
- Commit()：TM 调用该接口要求各个本地事务提交
- Rollback()：TM 调用该接口要求各个本地事务回滚


### 优点
尽量保证了数据的强一致性，适合对数据强一致性要求很高的关键领域。（其实也不能 100% 保证强一致）


### 缺点
#### 1. 第一阶段同步阻塞
2PC 是一个同步阻塞协议，第一个阶段中，事务协调者会等待所有参与者响应才会进行下一步操作。（当然第一阶段的协调者有超时机制，假设因为网络原因没有收到某个参与者的响应或某个参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令）

在这期间，各个参与者上面的相关资源被排他锁住，参与者中意图使用这些资源的本地事务只能等待。因为存在这种同步阻塞问题，所以影响了各个参与者的本地事务并发度；

实现复杂，牺牲了可用性，对性能影响较大，不适合高并发的场景。

#### 2. 单点故障
一旦事务管理器出现故障，整个系统不可用

#### 3. 第二阶段协调者没有超时机制
在第二阶段，协调者没有超时机制。协调者向所有的参与者发送了提交指令，如果一个参与者未返回 ACK，那么协调者不知道这个参与者内部发生了什么（这个参与者可能根本没收到提交指令，一直处于等待接收提交指令的状态；也可能收到了，并成功执行了本地提交，但返回的 ACK 由于网络故障未送到协调者上），只能不断重试，无法决定下一步是否进行全体参与者的回滚。

#### 4. 仅适用于数据库层面的分布式事务场景
我们业务有时候不仅仅涉及数据库，也有可能是上传一张图片或者发送一条短信。而且像 Java 中的 JTA 只能解决一个应用下多数据库的分布式事务问题，跨服务了就不能用了。


### 总结
2PC 基于 XA 规范的实现。

**本质：牺牲一部分可用性来换取一致性，是一种强一致性方案。**


### 参考
- [1.4w字，25 张图让你彻底掌握分布式事务原理 - allentofight - GitBook](https://codesea.gitbook.io/allentofight/xi-tong-she-ji/1.4w-zi-25-zhang-tu-rang-ni-che-di-zhang-wo-fen-bu-shi-shi-wu-yuan-li)
- [分布式事务 - 三太子敖丙 - 微信公众号](https://mp.weixin.qq.com/s/XknegP66mnYboiBx556Kzw)