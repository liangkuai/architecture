# 一致性哈希算法（Consistent hashing）

我们在做分库分表或者分布式存储的时候，如何进行数据分片（sharding）? 为了能让数据均匀分布，最常见的方式就是 Hash 取模。

### Hash 取模
对于 N 个节点，对 key 进行 `index = hash(key) % N` 计算出存储节点。

但是这种方式的容错性和扩展性差，比如：删除或者新增一个节点时，对于新的 key 没什么问题，但是老的 key 就会出现映射错误。为了解决这个问题就得重新计算所有的 key，并重新分配，但是代价昂贵，可能对正在运行的系统产生影响。

除了重新分配所有 key，还有一种更好的方案就是「一致性哈希算法」。


---
### 一致性哈希算法
一致性哈希算法是将 key 映射到值为 `0 ~ 2^32-1` 的范围内，收尾相连，形成一个环。

1. 先将各个节点的 ip 或者主机名作为唯一 key，进行 `hash(key)`，计算出的 hash 值就是节点在环上的位置。
2. 对于存储的数据，同样对 key 进行 `hash(key)`，
    - 如果计算的 hash 值刚好落在某个节点上，那就直接存储；
    - 如果没有对应的节点，那就在哈希环上顺时针查找最近的节点，进行存储。

#### 1. 删除节点（容错性）
只影响被删除节点与其上一个节点间的数据，会被重新分配到被删除节点的下一个节点。

#### 2. 新增节点（扩展性）
只影响新节点与上一个节点间的数据，会被重新分配到新节点中。

#### 3. 虚拟节点
当节点较少或节点分布不均时，容易导致数据存储不均衡。

一致性哈希算法引入虚拟节点来解决这个问题。也就是对每个节点生成多个虚拟节点（比如：对节点编号），分布到哈希环上。在确定 key 的存储节点时，先确定虚拟节点，再确定对应的实际物理节点。


#### 作用
相比于「Hash 取模」，一致性哈希算法就是为了在节点数发生变化时，尽量少迁移数据。


### 使用场景
- 分布式存储
- 负载均衡


### 代码实现

参考：[对一致性Hash算法，Java代码实现的深入研究 - 五月的仓颉 - 博客园](https://www.cnblogs.com/xrq730/p/5186728.html)